package com.shepherdmoney.interviewproject.controller;

import com.shepherdmoney.interviewproject.vo.request.AddCreditCardToUserPayload;
import com.shepherdmoney.interviewproject.vo.request.UpdateBalancePayload;
import com.shepherdmoney.interviewproject.vo.response.CreditCardView;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.shepherdmoney.interviewproject.repository.CreditCardRepository;
import com.shepherdmoney.interviewproject.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import com.shepherdmoney.interviewproject.model.CreditCard;
import com.shepherdmoney.interviewproject.model.User;
import org.springframework.http.HttpStatus;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;
import java.time.LocalDate;

@RestController
public class CreditCardController {

    // TODO: wire in CreditCard repository here (~1 line)
    @Autowired CreditCardRepository creditCardRepository;
    @Autowired UserRepository userRepository;
    @PostMapping("/credit-card")
    public ResponseEntity<Integer> addCreditCardToUser(@RequestBody AddCreditCardToUserPayload payload) {
        // TODO: Create a credit card entity, and then associate that credit card with user with given userId
        //       Return 200 OK with the credit card id if the user exists and credit card is successfully associated with the user
        //       Return other appropriate response code for other exception cases
        //       Do not worry about validating the card number, assume card number could be any arbitrary format and length

        // Return a bad_req if either given issuanceBank or cardNumber is empty or entirely blank
        if(payload.getCardIssuanceBank().isBlank() || payload.getCardNumber().isBlank()){
            System.out.println("Either issuanceBank or cardNumber input was blank");
            return new ResponseEntity<>(
                HttpStatus.BAD_REQUEST
            );
        }

        // Check if user exists, if not return bad_req
        if(userRepository.findById(payload.getUserId()).isEmpty()){
            System.out.println("User does not exist");
            return new ResponseEntity<>(
                 HttpStatus.BAD_REQUEST
            );
        }

        CreditCard creditCard = new CreditCard();
        // id for credit card is autogenerated
        // assign credit card parameters
        creditCard.setIssuanceBank(payload.getCardIssuanceBank());
        creditCard.setNumber(payload.getCardNumber());
        creditCard.setOwnerId(payload.getUserId());
        
        // Check if user already owns this credit card number
        List<CreditCard> creditCardsFromDatabase = creditCardRepository.findAll();
        for(CreditCard card : creditCardsFromDatabase){
            if(card.getNumber().equals(creditCard.getNumber()) && card.getOwnerId() == creditCard.getOwnerId()){
                // return bad req
                System.out.println("Card Number already exists for this user, try a different card");
                return new ResponseEntity<>(
                    HttpStatus.BAD_REQUEST
               );
            }
        }
        
        // add credit card to database
        creditCardRepository.save(creditCard);

        // update user credit cards list in database
        User user = userRepository.findById(payload.getUserId()).get();
        user.getCreditCardList().add(creditCard);
        userRepository.save(user);
        
        return new ResponseEntity<>(
            creditCard.getId(), HttpStatus.OK
       );
    }

    @GetMapping("/credit-card:all")
    public ResponseEntity<List<CreditCardView>> getAllCardOfUser(@RequestParam int userId) {
        // TODO: return a list of all credit card associated with the given userId, using CreditCardView class
        //       if the user has no credit card, return empty list, never return null
        
        // Check if user exists, if not return bad_req
        if(userRepository.findById(userId).isEmpty()){
            System.out.println("User does not exist");
            return new ResponseEntity<>(
                HttpStatus.BAD_REQUEST
            );
        }

        User user = userRepository.findById(userId).get();
        List<CreditCardView> list = new ArrayList<>();
        for(CreditCard cards : user.getCreditCardList()){
            list.add(new CreditCardView(cards.getIssuanceBank(), cards.getNumber()));
        }
        return new ResponseEntity<>(
            list, HttpStatus.OK
        );
    }

    @GetMapping("/credit-card:user-id")
    public ResponseEntity<Integer> getUserIdForCreditCard(@RequestParam String creditCardNumber) {
        // TODO: Given a credit card number, efficiently find whether there is a user associated with the credit card
        //       If so, return the user id in a 200 OK response. If no such user exists, return 400 Bad Request
        List<CreditCard> creditCardsFromDatabase = creditCardRepository.findAll();
        // loop through all cards from database and check if any has the given credit card number
        for(CreditCard card : creditCardsFromDatabase){
            // if so return bad request
            if(card.getNumber().equals(creditCardNumber)){
                System.out.println("Credit Card Number is associated with a user");
                return new ResponseEntity<>(
                    card.getOwnerId(), HttpStatus.OK
                );
            }
        }
        
        return new ResponseEntity<>(
           HttpStatus.BAD_REQUEST
        );
    }

    @PostMapping("/credit-card:update-balance")
    public ResponseEntity<String> postMethodName(@RequestBody UpdateBalancePayload[] payload) {
        //TODO: Given a list of transactions, update credit cards' balance history.
        //      1. For the balance history in the credit card
        //      2. If there are gaps between two balance dates, fill the empty date with the balance of the previous date
        //      3. Given the payload `payload`, calculate the balance different between the payload and the actual balance stored in the database
        //      4. If the different is not 0, update all the following budget with the difference
        //      For example: if today is 4/12, a credit card's balanceHistory is [{date: 4/12, balance: 110}, {date: 4/10, balance: 100}],
        //      Given a balance amount of {date: 4/11, amount: 110}, the new balanceHistory is
        //      [{date: 4/12, balance: 120}, {date: 4/11, balance: 110}, {date: 4/10, balance: 100}]
        //      Return 200 OK if update is done and successful, 400 Bad Request if the given card number
        //        is not associated with a card.

        // store a cache to access credit card numbers and their corresponding ids
        // faster
        HashMap<String, Integer> creditCardNumCache = new HashMap<>();

        for(CreditCard card : creditCardRepository.findAll()){
            creditCardNumCache.put(card.getNumber(), card.getId());
        }
        
        for(UpdateBalancePayload balancePayload : payload){
            // check if given card number is associated with a card
            if(!creditCardNumCache.containsKey(balancePayload.getCreditCardNumber())){
                // if not return 404 bad request
                return new ResponseEntity<>(
                    "The given card number is not associated with a card", HttpStatus.BAD_REQUEST
                 );
            }

            int cardId = creditCardNumCache.get(balancePayload.getCreditCardNumber());
            CreditCard card = creditCardRepository.findById(cardId ).get();
            // sort balance history in reverse order to update balance 
            card.setBalanceHistory(sortBalanceHistory(card.getBalanceHistory()));
            // update the balance amount
            updateBalanceHistory(card.getBalanceHistory(), balancePayload);
            // sort balance history in chronological order
            creditCardRepository.save(card);
            System.out.println(card.getBalanceHistory().toString());
        }
        return new ResponseEntity<>(
            "Successful Update", HttpStatus.OK
         );
    }
    private static Map<LocalDate, Double> sortBalanceHistory(Map<LocalDate, Double> balHistory){
        Map<LocalDate, Double> map = new TreeMap<>();
        map.putAll(balHistory);
        return map;
    }

    private static void updateBalanceHistory(Map<LocalDate, Double> balHistory, UpdateBalancePayload balancePayload){
            //      For example: if today is 4/12, a credit card's balanceHistory is [{date: 4/12, balance: 110}, {date: 4/10, balance: 100}],
            //      Given a balance amount of {date: 4/11, amount: 110}, the new balanceHistory is
            //      [{date: 4/12, balance: 120}, {date: 4/11, balance: 110}, {date: 4/10, balance: 100}]
            //      Return 200 OK if update is done and successful, 400 Bad Request if the given card number
            //        is not associated with a card.


            // 2. If there are gaps between two balance dates, fill the empty date with the balance of the previous date
            // Find gaps and fill those empty dates with balance of prev date
            int i = 0;
            Map<LocalDate, Double> balHistCopy = new TreeMap<>(balHistory); 
            LocalDate firstDate = null;
            LocalDate lastDate = null;
            if(balHistory.size() > 1){
                for(LocalDate keyDate: balHistory.keySet()){
                    // found gap!
                    if(!balHistory.containsKey(keyDate.plusDays(1)) && i < balHistory.size() - 1){
                        // fill in first empty date
                        balHistCopy.put(keyDate.plusDays(1), balHistCopy.get(keyDate));
                        int count = 2;
                        while(!balHistory.containsKey(keyDate.plusDays(count)) && count <= balHistory.size() + 1){
                            // fill in  remaining empty dates until next date already exists or when the end of list 
                            // is reached
                            balHistCopy.put(keyDate.plusDays(count), balHistCopy.get(keyDate));
                            count++;
                        }
                    }
                    if( i == 0){
                        firstDate = keyDate;
                    }
                    if( i == balHistory.size() - 1){
                        lastDate = keyDate;
                    }
                    i++;
                }
            }
            // 3. Given the payload `payload`, calculate the balance different between the payload and the actual balance stored in the database
            double difference = 0;
            double actualBalance = 0;
            // edge case 
            if(balHistCopy.containsKey(balancePayload.getBalanceDate())){
                actualBalance = balHistCopy.get(balancePayload.getBalanceDate());
            }
            difference = balancePayload.getBalanceAmount() - actualBalance;
            // 4. If the different is not 0, update all the following budget with the difference
            if(difference != 0){
                balHistory.put(balancePayload.getBalanceDate(), balancePayload.getBalanceAmount());
                for(LocalDate keyDate: balHistory.keySet()){
                    if(keyDate.getDayOfMonth() - balancePayload.getBalanceDate().getDayOfMonth() > 0){
                        balHistory.put(keyDate, balHistory.get(keyDate) + difference);   
                    }
                }
            }

    }
}
